<!DOCTYPE html>
<!--

The Resurrector - Standalone Nostr Profile Resurrection Tool

Based on: https://github.com/Yonle/undelete-my-nostr
Part of: Plebs vs. Zombies (https://plebsvszombies.cc)

How Nostr account deletion works:
You send metadata about your profile, but you put "deleted: true" on it, like this:

{
  "name": "Your Name",
  "about": "Your bio",
  "deleted": true // <--- This marks the account as deleted
}

This tool works by:
1. Sending an Event Deletion event (kind 5) about the conflicting deleted profile event
2. Optionally publishing a new clean profile without the deleted flag

-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>The Resurrector | Undelete Your Nostr Profile</title>
  <meta name="description" content="Bring your deleted Nostr profile back to life! Works with browser extensions or nsec." />

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://plebsvszombies.cc/resurrector">
  <meta property="og:title" content="The Resurrector | Undelete Your Nostr Profile">
  <meta property="og:description" content="Bring your deleted Nostr profile back to life! Works with browser extensions or nsec.">
  <meta property="og:image" content="https://plebsvszombies.cc/resurrector-social-share.jpg">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://plebsvszombies.cc/resurrector">
  <meta property="twitter:title" content="The Resurrector | Undelete Your Nostr Profile">
  <meta property="twitter:description" content="Bring your deleted Nostr profile back to life! Works with browser extensions or nsec.">
  <meta property="twitter:image" content="https://plebsvszombies.cc/resurrector-social-share.jpg">

  <!-- Google Fonts - matching main app -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Creepster&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- Tailwind CSS CDN for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Configure Tailwind to match the main app
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'zombie-green': '#5cdb5c',
            'zombie-dark': '#2c3531',
            'pleb-gold': '#ffd700',
            'pleb-blue': '#1e90ff',
            'pleb-purple': '#8e30eb',
          },
          fontFamily: {
            'horror': ['"Creepster"', 'cursive'],
            'main': ['"Inter"', 'sans-serif'],
          }
        }
      }
    }
  </script>

  <style>
    body {
      background: #111827;
      color: #e5e7eb;
      font-family: 'Inter', sans-serif;
    }

    h1, h2, h3 {
      font-family: 'Creepster', cursive;
      color: #5cdb5c;
    }

    .zombie-green {
      color: #5cdb5c;
    }

    .btn-primary {
      background: #5cdb5c;
      color: #2c3531;
      font-weight: 600;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      transition: all 0.2s;
      cursor: pointer;
      border: none;
    }

    .btn-primary:hover:not(:disabled) {
      background: #4ade80;
    }

    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-secondary {
      background: #374151;
      color: #e5e7eb;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      font-weight: 600;
      transition: all 0.2s;
      cursor: pointer;
      border: none;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #4b5563;
    }

    .btn-secondary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .card {
      background: #2c3531;
      border: 1px solid #374151;
      border-radius: 0.75rem;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    input[type="password"],
    input[type="text"],
    textarea {
      width: 100%;
      padding: 0.75rem;
      background: #111827;
      border: 1px solid #374151;
      border-radius: 0.5rem;
      color: #e5e7eb;
      font-size: 0.875rem;
    }

    input:focus,
    textarea:focus {
      outline: none;
      border-color: #10b981;
    }

    .log-info { color: #9ca3af; }
    .log-success { color: #4ade80; }
    .log-warning { color: #fbbf24; }
    .log-error { color: #f87171; }

    /* Lightning Animation - from Primal Spark */
    .lightning-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9999;
      transition: background 0.2s;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: visible;
      opacity: 0;
    }

    .lightning-container.active {
      opacity: 1;
    }

    .lightning-svg {
      position: absolute;
      top: 0;
      width: 100vw;
      height: 100vh;
      filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.7));
      left: 50%;
      transform: translateX(-50%);
      overflow: visible;
    }

    .rayo {
      stroke-linecap: round;
      opacity: 0;
      animation: aparecer 0.2s ease-out, desvanecer 0.6s ease-in 0.2s;
      fill: none;
    }

    @keyframes aparecer {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes desvanecer {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    .flash {
      animation: flash 0.2s;
    }

    @keyframes flash {
      0% { background: rgba(255, 255, 255, 0.3); }
      100% { background: transparent; }
    }
  </style>
</head>

<body class="p-4 md:p-8">
  <div class="max-w-4xl mx-auto">
    <!-- Header -->
    <div class="text-center mb-8">
      <div class="text-6xl mb-4 flex items-center justify-center gap-2">
        <span style="display: inline-block; transform: scaleX(-1);">‚ö°</span>
        <span>üßü‚Äç‚ôÇÔ∏è</span>
        <span>‚ö°</span>
      </div>
      <h1 class="text-4xl font-bold mb-2 zombie-green">The Resurrector</h1>
      <p class="text-gray-300 mb-4">Bring your deleted Nostr profile back to life!</p>
      <p class="text-sm text-gray-400">
        Part of <a href="https://plebsvszombies.cc" class="zombie-green hover:underline" target="_blank">Plebs vs. Zombies</a>
      </p>
    </div>

    <!-- Security Warning -->
    <div class="card bg-yellow-900/20 border-yellow-600/50">
      <div class="flex items-start gap-3">
        <div class="text-2xl">üîí</div>
        <div class="flex-1">
          <h3 class="text-lg font-medium text-yellow-400 mb-2">Security Notice</h3>
          <div class="space-y-2">
            <div class="flex items-start gap-3">
              <span class="text-lg flex-shrink-0">‚ö°</span>
              <span class="text-sm text-gray-300"><strong>Recommended:</strong> <a href="/" class="zombie-green hover:underline">Connect with Browser Extension</a> (NIP-07) like Alby or nos2x</span>
            </div>
            <div class="flex items-start gap-3">
              <span class="text-lg flex-shrink-0">üõ°Ô∏è</span>
              <span class="text-sm text-gray-300"><strong>Fallback:</strong> If you must use an nsec, it never leaves your browser</span>
            </div>
            <div class="flex items-start gap-3">
              <span class="text-lg flex-shrink-0">üîê</span>
              <span class="text-sm text-gray-300"><strong>Privacy:</strong> All operations happen locally - no data sent to any server</span>
            </div>
            <div class="flex items-start gap-3">
              <span class="text-lg flex-shrink-0">üëÅÔ∏è</span>
              <span class="text-sm text-gray-300"><strong>Open Source:</strong> You can inspect the code below or on <a href="https://github.com/dmnyc/plebs-vs-zombies" class="zombie-green hover:underline" target="_blank">GitHub</a></span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- How It Works -->
    <div class="card bg-gray-800/50 border-yellow-500/30">
      <div class="flex items-start gap-3">
        <div class="text-2xl">üí°</div>
        <div class="flex-1">
          <h3 class="text-lg font-medium text-yellow-400 mb-2">How It Works</h3>
          <p class="text-sm text-gray-300 mb-3">
            Nostr accounts are "deleted" by setting a <code class="bg-gray-900 px-1 rounded text-yellow-300">"deleted": true</code> flag in your profile metadata. The Resurrector:
          </p>
          <div class="space-y-2">
            <div class="flex items-start gap-3">
              <span class="flex-shrink-0 w-6 h-6 rounded-full bg-zombie-green text-gray-900 font-bold text-sm flex items-center justify-center">1</span>
              <span class="text-sm text-gray-300">Scans for profile events with the deleted flag</span>
            </div>
            <div class="flex items-start gap-3">
              <span class="flex-shrink-0 w-6 h-6 rounded-full bg-zombie-green text-gray-900 font-bold text-sm flex items-center justify-center">2</span>
              <span class="text-sm text-gray-300">Sends a deletion event (kind 5) to remove the deleted profile</span>
            </div>
            <div class="flex items-start gap-3">
              <span class="flex-shrink-0 w-6 h-6 rounded-full bg-zombie-green text-gray-900 font-bold text-sm flex items-center justify-center">3</span>
              <span class="text-sm text-gray-300">Publishes a clean version of your profile without the deleted flag</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Authentication Method -->
    <div class="card">
      <h2 class="text-2xl font-bold mb-4">Step 1: Choose Authentication Method</h2>

      <div class="space-y-3 mb-4">
        <label class="flex items-start gap-3 p-3 border border-gray-700 rounded-lg cursor-pointer hover:border-zombie-green transition-colors">
          <input
            type="radio"
            name="authMethod"
            value="npub"
            id="auth-npub"
            class="mt-1"
            checked
          />
          <div class="flex-1">
            <div class="font-medium text-blue-400">Check Any Profile (npub)</div>
            <div class="text-sm text-gray-400">Read-only scan - can't resurrect without authentication</div>
          </div>
        </label>

        <label class="flex items-start gap-3 p-3 border border-gray-700 rounded-lg cursor-pointer hover:border-zombie-green transition-colors">
          <input
            type="radio"
            name="authMethod"
            value="nsec"
            id="auth-nsec"
            class="mt-1"
          />
          <div class="flex-1">
            <div class="font-medium text-yellow-400">Private Key (nsec/hex)</div>
            <div class="text-sm text-gray-400">Required to resurrect profiles</div>
          </div>
        </label>
      </div>

      <!-- Npub Input (shown by default) -->
      <div id="npub-input-section" class="mb-4">
        <label class="block text-sm font-medium mb-2">Public Key (npub or hex)</label>
        <input
          type="text"
          id="npub-input"
          placeholder="npub1... or hex pubkey"
          class="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-sm focus:outline-none focus:border-zombie-green mb-2"
        />
        <p class="text-xs text-blue-400">‚ÑπÔ∏è Read-only mode - you can scan but not resurrect without signing</p>
      </div>

      <!-- Nsec Input (hidden by default) -->
      <div id="nsec-input-section" class="hidden mb-4">
        <label class="block text-sm font-medium mb-2">Private Key (nsec or hex)</label>
        <input
          type="password"
          id="nsec-input"
          placeholder="nsec1... or hex private key"
          class="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg text-sm focus:outline-none focus:border-zombie-green mb-2"
        />
        <p class="text-xs text-yellow-400">‚ö†Ô∏è Your private key never leaves this browser window</p>
      </div>

      <!-- Relay List -->
      <div class="mb-4">
        <label class="block text-sm font-medium mb-2">Nostr Relays (one per line)</label>
        <textarea
          id="relay-input"
          rows="5"
          placeholder="wss://relay.damus.io&#10;wss://relay.nostr.band&#10;wss://nos.lol&#10;wss://relay.primal.net"
        ></textarea>
        <p class="text-xs text-gray-400 mt-1">Common relays are pre-filled. You can add or remove as needed.</p>
      </div>
    </div>

    <!-- Main Actions Section -->
    <div class="card">
      <h2 class="text-2xl font-bold mb-4" id="step2-heading">Step 2: Check Profile Status</h2>

      <!-- Read-only notice for npub mode -->
      <div id="npub-readonly-notice" class="bg-blue-900/20 border border-blue-600/40 p-3 rounded-lg mb-4">
        <p class="text-sm text-blue-300">
          ‚ÑπÔ∏è <strong>Read-Only Mode:</strong> You can scan profiles with an npub, but resurrection requires authentication. Choose "Browser Extension" or "Private Key" above to resurrect a profile.
        </p>
      </div>

      <div class="bg-yellow-900/10 border border-yellow-600/20 p-3 rounded-lg mb-4">
        <p class="text-sm text-gray-400">
          üí° <strong class="text-yellow-400">How it works:</strong> Click the button below to scan for deleted profiles across all relays. If found and you're authenticated, it will remove the deleted flag and publish a clean version.
        </p>
      </div>

      <div class="flex gap-3 flex-wrap">
        <button onclick="forceResurrection()" class="btn-primary text-lg px-8 py-4" id="force-btn" style="background: #5cdb5c;">
          üîç Check Profile
        </button>

        <button onclick="clearLogs()" class="btn-secondary hidden" id="clear-logs-btn">
          üóëÔ∏è Clear Logs
        </button>
      </div>
    </div>

    <!-- Scan Results Section (separate card) -->
    <div id="results-section" class="hidden">
      <!-- This will be populated by JavaScript -->
    </div>

    <!-- Advanced Tools (Collapsible) -->
    <div id="advanced-tools-section" class="card bg-gray-800/30 hidden">
      <details>
        <summary class="text-lg font-medium cursor-pointer hover:text-zombie-green transition-colors">
          üîß Advanced Diagnostic Tools
        </summary>

        <div class="mt-4 space-y-3">
          <p class="text-xs text-gray-400 mb-3">
            These tools help diagnose specific issues. Most users won't need these.
          </p>

          <div class="flex gap-3 flex-wrap">
            <button onclick="scanProfile()" class="btn-secondary" id="scan-btn">
              üîç Basic Scan
            </button>

            <button onclick="deepScan()" class="btn-secondary" id="deep-scan-btn">
              üî¨ Deep Scan
            </button>

            <button onclick="publishToMissingRelays()" class="btn-secondary" id="publish-missing-btn">
              üì° Publish to Missing Relays
            </button>

            <button onclick="toggleKeepProfile()" class="btn-secondary" id="keep-profile-btn">
              Keep Profile: OFF
            </button>

            <button onclick="exportProfileData()" class="btn-secondary" id="export-btn">
              üíæ Export Profile JSON
            </button>
          </div>

          <div class="text-xs text-gray-400 mt-3 bg-gray-900/50 p-3 rounded">
            <p class="mb-2"><strong>Basic Scan:</strong> Quick check for deleted profiles</p>
            <p class="mb-2"><strong>Deep Scan:</strong> Comprehensive check across all relays and event types</p>
            <p class="mb-2"><strong>Publish to Missing Relays:</strong> Send your profile to specific relays that don't have it</p>
            <p><strong>Keep Profile:</strong> When OFF (recommended), publishes a new profile. When ON, only removes deleted events.</p>
          </div>
        </div>
      </details>
    </div>

    <!-- Logs -->
    <div id="log-section" class="card bg-gray-900 hidden">
      <h3 class="text-lg font-medium mb-3">Activity Log</h3>
      <div id="log-output" class="space-y-1 max-h-96 overflow-y-auto font-mono text-sm">
        <!-- Logs will appear here when actions are performed -->
      </div>
    </div>

    <!-- Help & Disclaimer Section -->
    <div class="card mt-6" style="background: rgba(55, 65, 81, 0.3);">
      <h3 class="text-lg font-medium mb-4">Need Help?</h3>
      <div class="space-y-3 text-sm text-gray-300 mb-6">
        <p>
          <strong class="text-yellow-400">Q: Why would my profile be deleted?</strong><br>
          Some Nostr clients allow you to "delete" your account by setting the <code class="bg-gray-900 px-1 rounded">deleted: true</code> flag in your profile.
        </p>
        <p>
          <strong class="text-yellow-400">Q: Is this safe?</strong><br>
          Yes! Your private key never leaves this browser window. All operations happen locally using secure cryptography.
        </p>
        <p>
          <strong class="text-yellow-400">Q: What's "Keep Profile Mode"?</strong><br>
          When OFF (recommended), it republishes your profile. When ON, it only removes the deleted events without republishing. Use for more control.
        </p>
      </div>

      <!-- Important Disclaimer -->
      <div style="background: rgba(124, 45, 18, 0.2); border: 1px solid rgba(249, 115, 22, 0.4); border-radius: 0.75rem; padding: 1rem;">
        <div class="flex items-start gap-3">
          <div class="text-2xl">‚ö†Ô∏è</div>
          <div class="flex-1">
            <h3 class="text-lg font-medium mb-2" style="color: #fb923c;">Important: Client Compatibility Disclaimer</h3>
            <p class="text-sm text-gray-300 mb-3">
              The Resurrector is a <strong>best effort</strong> service. While it works in the majority of cases we've tested,
              there is <strong>no guarantee that all Nostr clients will behave the same way</strong>.
            </p>

            <div class="mb-3">
              <p class="text-sm font-medium mb-2" style="color: #fed7aa;">Known Client-Specific Issues:</p>
              <ul class="text-sm text-gray-300 space-y-2 list-disc list-inside">
                <li>
                  <strong style="color: #fdba74;">Yakihonne:</strong> May require clearing the app cache or completely
                  uninstalling and reinstalling the app before it will recognize your nsec as not deleted.
                </li>
                <li>
                  <strong style="color: #fdba74;">Primal:</strong> Some users may still experience errors logging in if
                  delete flags are present in remote cache services (a known issue on their end).
                </li>
                <li>
                  <strong style="color: #fdba74;">Other clients:</strong> Each client handles profile metadata differently.
                  Some may cache deleted status or have different relay configurations.
                </li>
              </ul>
            </div>

            <p class="text-sm text-gray-300 mb-2">
              <strong style="color: #fb923c;">What We Offer:</strong> We publish the necessary events to clear the deleted flag
              from your profile across relays. In most cases tested, this successfully restores profile usability.
            </p>

            <p class="text-sm text-gray-400 italic">
              We provide this service with no assurances that every client will accept your nsec after resurrection.
              Results may vary depending on the client's implementation and caching behavior.
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- Footer -->
    <div class="text-center text-sm text-gray-500 mt-8">
      <p>Made with üß† for the Nostr community</p>
      <p class="mt-2">
        <a href="https://github.com/dmnyc/plebs-vs-zombies" class="zombie-green hover:underline" target="_blank">View on GitHub</a>
        ¬∑
        <a href="https://plebsvszombies.cc" class="zombie-green hover:underline" target="_blank">Plebs vs. Zombies</a>
      </p>
    </div>
  </div>

  <!-- Lightning Animation Overlay -->
  <div id="lightning-container" class="lightning-container">
    <svg id="lightning-svg" class="lightning-svg"></svg>
  </div>

  <!-- NostrTools Library (local copy) -->
  <script src="/nostr.bundle.js"></script>

  <script>
    // Global state
    let pool = null;
    let keepProfile = false;
    let deletedProfiles = [];

    // Initialize on load
    document.addEventListener('DOMContentLoaded', async () => {
      // NostrTools should be available globally from the bundle
      if (!window.NostrTools) {
        log('ERROR: NostrTools library not loaded!', 'error');
        return;
      }

      // Set up auth method toggle
      document.querySelectorAll('input[name="authMethod"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
          const npubSection = document.getElementById('npub-input-section');
          const nsecSection = document.getElementById('nsec-input-section');
          const npubInput = document.getElementById('npub-input');
          const nsecInput = document.getElementById('nsec-input');
          const readonlyNotice = document.getElementById('npub-readonly-notice');
          const forceBtn = document.getElementById('force-btn');
          const step2Heading = document.getElementById('step2-heading');
          const advancedTools = document.getElementById('advanced-tools-section');

          // Clear input fields when switching modes for security
          npubInput.value = '';
          nsecInput.value = '';

          // Hide all input sections first
          npubSection.classList.add('hidden');
          nsecSection.classList.add('hidden');
          readonlyNotice.classList.add('hidden');

          // Show the appropriate input section and update UI
          if (e.target.value === 'npub') {
            npubSection.classList.remove('hidden');
            readonlyNotice.classList.remove('hidden');
            forceBtn.innerHTML = 'üîç Check Profile';
            forceBtn.style.background = '#5cdb5c'; // zombie-green
            step2Heading.textContent = 'Step 2: Check Profile Status';
            advancedTools.classList.add('hidden');
          } else if (e.target.value === 'nsec') {
            nsecSection.classList.remove('hidden');
            forceBtn.innerHTML = '‚ö° Resurrect Profile';
            forceBtn.style.background = '#d97706'; // orange
            step2Heading.textContent = 'Step 2: Fix Your Profile';
            advancedTools.classList.remove('hidden');
          }
        });
      });

      // Initialize SimplePool
      try {
        if (!window.NostrTools || !window.NostrTools.SimplePool) {
          throw new Error('NostrTools library not loaded properly');
        }
        pool = new window.NostrTools.SimplePool();
        log('NostrTools loaded successfully', 'success');

        // Set default relays
        setDefaultRelays();
      } catch (error) {
        log('Failed to load NostrTools: ' + error.message, 'error');
      }
    });

    function setDefaultRelays() {
      const defaultRelays = [
        // Primal relays (critical for Primal app)
        'wss://relay.primal.net',
        // Yakihonne relays (critical for Yakihonne app)
        'wss://nostr-01.yakihonne.com',
        'wss://nostr-02.yakihonne.com',
        // Other popular relays
        'wss://relay.damus.io',
        'wss://relay.nostr.band',
        'wss://nos.lol',
        'wss://nostr.wine',
        'wss://relay.snort.social',
        'wss://nostr.mom',
        'wss://purplepag.es'
      ].join('\n');
      document.getElementById('relay-input').value = defaultRelays;
    }

    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const logOutput = document.getElementById('log-output');
      const entry = document.createElement('div');
      entry.className = `flex gap-2 text-xs log-${type}`;

      const timeSpan = document.createElement('span');
      timeSpan.className = 'text-gray-500';
      timeSpan.textContent = timestamp;

      const messageSpan = document.createElement('span');
      messageSpan.textContent = message;

      entry.appendChild(timeSpan);
      entry.appendChild(messageSpan);
      logOutput.appendChild(entry);
      logOutput.scrollTop = logOutput.scrollHeight;
      console.log(`[Resurrector ${type.toUpperCase()}] ${message}`);

      // Show log section and Clear Logs button when logs exist
      const logSection = document.getElementById('log-section');
      if (logSection) {
        logSection.classList.remove('hidden');
      }
      const clearLogsBtn = document.getElementById('clear-logs-btn');
      if (clearLogsBtn) {
        clearLogsBtn.classList.remove('hidden');
      }
    }

    function clearLogs() {
      const logOutput = document.getElementById('log-output');
      logOutput.innerHTML = '';

      // Hide log section and Clear Logs button after clearing
      const logSection = document.getElementById('log-section');
      if (logSection) {
        logSection.classList.add('hidden');
      }
      const clearLogsBtn = document.getElementById('clear-logs-btn');
      if (clearLogsBtn) {
        clearLogsBtn.classList.add('hidden');
      }
    }

    function toggleKeepProfile() {
      keepProfile = !keepProfile;
      const btn = document.getElementById('keep-profile-btn');
      btn.textContent = `Keep Profile: ${keepProfile ? 'ON' : 'OFF'}`;
      log(`Keep Profile mode: ${keepProfile ? 'ON' : 'OFF'}`, 'info');
    }

    function generateLightning() {
      const svg = document.getElementById('lightning-svg');
      const container = document.getElementById('lightning-container');

      if (!svg || !container) return;

      const ancho = container.clientWidth;
      const altura = container.clientHeight;

      // Calculate a safe starting position
      const safeWidthStart = ancho * 0.15;
      const safeWidthEnd = ancho * 0.85;
      const safeWidth = safeWidthEnd - safeWidthStart;

      const xInicio = safeWidthStart + Math.random() * safeWidth;
      let yActual = 0;
      let zigzag = `M${xInicio},${yActual}`;

      const grosor = Math.random() * 3 + 2;
      const color = Math.random() > 0.5 ? 'white' : 'yellow';

      // Create zigzag pattern
      const segments = Math.floor(Math.random() * 3 + 5);

      for (let i = 0; i < segments; i++) {
        const maxOffset = Math.min(100, safeWidth * 0.25);
        const xOffset = (Math.random() - 0.5) * maxOffset;

        let yOffset;
        if (i === segments - 1) {
          yOffset = altura - yActual;
        } else {
          yOffset = (altura / segments) * (1 + Math.random() * 0.5);
        }

        yActual += yOffset;

        let newX = xInicio + xOffset;
        const edgeBuffer = ancho * 0.08;
        if (newX < edgeBuffer) newX = edgeBuffer;
        if (newX > ancho - edgeBuffer) newX = ancho - edgeBuffer;

        zigzag += ` L${newX},${yActual}`;

        // Add random branches
        if (Math.random() > 0.7) {
          const branchOffsetMax = maxOffset * 0.8;
          const branchOffset = (Math.random() - 0.5) * branchOffsetMax;
          let branchX = newX + branchOffset;

          const edgeBuffer = ancho * 0.05;
          if (branchX < edgeBuffer) branchX = edgeBuffer;
          if (branchX > ancho - edgeBuffer) branchX = ancho - edgeBuffer;

          const branchY = yActual + Math.random() * 30;
          zigzag += ` M${newX},${yActual} L${branchX},${branchY} M${newX},${yActual}`;
        }
      }

      // Create SVG path
      const linea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      linea.setAttribute('d', zigzag);
      linea.setAttribute('class', 'rayo');
      linea.setAttribute('stroke', color);
      linea.setAttribute('stroke-width', grosor.toString());
      linea.setAttribute('fill', 'none');
      svg.appendChild(linea);

      // Add flash effect
      container.classList.add('flash');
      setTimeout(() => {
        container.classList.remove('flash');
      }, 200);

      // Clean up lightning after animation
      setTimeout(() => {
        if (svg.contains(linea)) {
          svg.removeChild(linea);
        }
      }, 800);
    }

    async function playResurrectionAnimation() {
      const container = document.getElementById('lightning-container');

      // Show container
      container.classList.add('active');

      // Generate multiple lightning bolts
      generateLightning();
      setTimeout(() => generateLightning(), 150);
      setTimeout(() => generateLightning(), 300);

      // Wait for animations to complete
      await new Promise(resolve => setTimeout(resolve, 1200));

      // Hide container
      container.classList.remove('active');
    }

    async function getPrivateKey() {
      const authMethod = document.querySelector('input[name="authMethod"]:checked').value;

      if (authMethod === 'npub') {
        // Read-only mode, no private key
        return null;
      } else {
        const nsecInput = document.getElementById('nsec-input').value.trim();
        if (!nsecInput) {
          throw new Error('Please enter your private key (nsec or hex)');
        }

        // Validate input - reject if it's an npub or nprofile
        if (nsecInput.startsWith('npub') || nsecInput.startsWith('nprofile')) {
          throw new Error('Invalid input: You entered a public key (npub/nprofile) but a private key (nsec) is required for resurrection. Switch to "Check Any Profile" mode to scan with an npub.');
        }

        // Decode nsec if needed
        if (nsecInput.startsWith('nsec')) {
          const decoded = window.NostrTools.nip19.decode(nsecInput);
          return decoded.data;
        }
        return nsecInput;
      }
    }

    async function getPublicKey(privkey) {
      const authMethod = document.querySelector('input[name="authMethod"]:checked').value;

      // Handle npub input
      if (authMethod === 'npub') {
        const npubInput = document.getElementById('npub-input').value.trim();
        if (!npubInput) {
          throw new Error('Please enter a public key (npub or hex)');
        }

        // Validate input - reject if it's an nsec
        if (npubInput.startsWith('nsec')) {
          throw new Error('Invalid input: You entered a private key (nsec) but a public key (npub) is required. Switch to "Private Key" mode to use your nsec for resurrection.');
        }

        // Decode npub or nprofile if needed
        if (npubInput.startsWith('npub') || npubInput.startsWith('nprofile')) {
          const decoded = window.NostrTools.nip19.decode(npubInput);
          // nprofile returns an object with pubkey, npub returns the pubkey directly
          return decoded.data.pubkey || decoded.data;
        }
        return npubInput;
      }

      // Handle privkey
      return window.NostrTools.getPublicKey(privkey);
    }

    function getRelays() {
      const relayText = document.getElementById('relay-input').value;
      return relayText.split('\n').map(r => r.trim()).filter(r => r.startsWith('wss://'));
    }

    async function signEvent(event, privkey) {
      event.created_at = Math.floor(Date.now() / 1000);

      // Use finalizeEvent which handles pubkey, id, and sig in one call
      event = window.NostrTools.finalizeEvent(event, privkey);

      log(`Signed event ${event.id.substring(0, 8)}... with ${event.pubkey.substring(0, 8)}...`, 'success');
      return event;
    }

    async function scanProfile() {
      const scanBtn = document.getElementById('scan-btn');
      scanBtn.disabled = true;
      scanBtn.textContent = 'üîç Scanning...';
      deletedProfiles = [];

      try {
        const privkey = await getPrivateKey();
        const pubkey = await getPublicKey(privkey);
        const relays = getRelays();

        if (relays.length === 0) {
          throw new Error('Please add at least one relay');
        }

        log(`Starting scan for pubkey: ${pubkey.substring(0, 8)}...`, 'info');
        log(`Using ${relays.length} relay(s)`, 'info');
        log('Fetching profile metadata events...', 'info');

        // Fetch all kind 0 events for this user
        const events = await pool.querySync(relays, {
          kinds: [0],
          authors: [pubkey]
        });

        log(`Found ${events.length} profile event(s)`, 'info');

        // Check each for deleted flag
        for (const event of events) {
          try {
            const metadata = JSON.parse(event.content);

            // Debug log
            log(`Checking event ${event.id.substring(0, 8)}... - deleted flag: ${metadata.deleted}`, 'info');
            console.log('Full event:', event);
            console.log('Full metadata:', metadata);

            if (metadata.deleted === true) {
              log(`‚ö†Ô∏è Found deleted profile: ${event.id.substring(0, 8)}...`, 'warning');
              deletedProfiles.push({
                event,
                metadata,
                eventId: event.id,
                createdAt: event.created_at
              });
            } else {
              log(`‚úÖ Profile looks fine: ${event.id.substring(0, 8)}...`, 'success');
            }
          } catch (error) {
            log(`Error parsing event ${event.id.substring(0, 8)}...: ${error.message}`, 'error');
          }
        }

        // Display results
        displayResults(privkey);

        if (deletedProfiles.length === 0) {
          log('üéâ No deleted profiles found! Your account looks healthy.', 'success');
        }

      } catch (error) {
        log(`Scan failed: ${error.message}`, 'error');
      } finally {
        scanBtn.disabled = false;
        scanBtn.textContent = 'üîç Scan My Profile';
      }
    }

    function displayResults(privkey) {
      const resultsSection = document.getElementById('results-section');
      const authMethod = document.querySelector('input[name="authMethod"]:checked').value;
      const isReadOnly = authMethod === 'npub';

      if (deletedProfiles.length === 0) {
        resultsSection.innerHTML = `
          <div class="card border-green-500/50">
            <div class="flex items-center gap-3">
              <div class="text-3xl">‚úÖ</div>
              <div>
                <h3 class="text-lg font-medium text-green-400">Profile Looks Healthy!</h3>
                <p class="text-sm text-gray-300">No deleted profiles found.</p>
              </div>
            </div>
          </div>
        `;
        resultsSection.classList.remove('hidden');
        return;
      }

      let html = `
        <div class="card bg-red-900/20 border-red-500/50">
          <h2 class="text-2xl font-bold mb-4 text-red-400">‚ö†Ô∏è Deleted Profile Found!</h2>
      `;

      if (isReadOnly) {
        html += `
          <div class="bg-yellow-900/30 border border-yellow-600/50 p-3 rounded-lg mb-4">
            <p class="text-sm text-yellow-400">
              ‚ö†Ô∏è You're in read-only mode. To resurrect this profile, choose "Private Key" authentication above, or use the <a href="/" class="zombie-green hover:underline">Browser Extension (NIP-07) method</a>.
            </p>
          </div>
        `;
      }

      deletedProfiles.forEach((profile, index) => {
        const date = new Date(profile.createdAt * 1000).toLocaleString();
        html += `
          <div class="bg-gray-800 p-4 rounded-lg border border-gray-700 mb-4">
            <div class="mb-3">
              <div class="font-mono text-sm text-gray-400">Event ID: ${profile.eventId.substring(0, 16)}...</div>
              <div class="text-xs text-gray-500">Created: ${date}</div>
            </div>
            <div class="mb-3">
              <h4 class="text-sm font-medium text-gray-300 mb-1">Profile Data:</h4>
              <pre class="text-xs bg-gray-900 p-2 rounded overflow-x-auto text-gray-400">${JSON.stringify(profile.metadata, null, 2)}</pre>
            </div>
            ${isReadOnly ?
              '<div class="bg-gray-700 text-gray-400 w-full py-3 px-4 rounded text-center">üîí Sign in to resurrect</div>' :
              `<button onclick="resurrectProfile(${index})" class="btn btn-primary w-full" id="resurrect-btn-${index}">‚ö° Resurrect This Profile</button>`
            }
          </div>
        `;
      });

      html += '</div>';
      resultsSection.innerHTML = html;
      resultsSection.classList.remove('hidden');
    }

    async function resurrectProfile(index) {
      const profile = deletedProfiles[index];
      const btn = document.getElementById(`resurrect-btn-${index}`);

      if (!confirm('Are you sure you want to resurrect this profile? This will publish new events to your relays.')) {
        return;
      }

      btn.disabled = true;
      btn.textContent = '‚ö° Resurrecting...';

      try {
        const privkey = await getPrivateKey();
        const relays = getRelays();

        log(`Starting resurrection for event: ${profile.eventId.substring(0, 8)}...`, 'info');

        // Step 1: Create and publish deletion event (kind 5)
        log('Creating deletion event (kind 5)...', 'info');

        let deletionEvent = {
          kind: 5,
          content: '',
          tags: [['e', profile.eventId]]
        };

        deletionEvent = await signEvent(deletionEvent, privkey);

        log('Publishing deletion event...', 'info');
        const delPubs = pool.publish(relays, deletionEvent);
        await Promise.allSettled(delPubs);
        log('‚úÖ Deletion event published!', 'success');

        // Step 2: Publish clean profile (if not in keep-profile mode)
        if (!keepProfile) {
          log('Creating clean profile metadata...', 'info');

          const cleanMetadata = { ...profile.metadata };

          // Add display_name if name exists but display_name doesn't
          if (cleanMetadata.name && !cleanMetadata.display_name) {
            cleanMetadata.display_name = cleanMetadata.name;
          }

          // Ensure proper deletion flags for Yakihonne compatibility
          delete cleanMetadata.deleted; // Remove old-style deleted flag
          cleanMetadata.is_deleted = false; // Add Yakihonne-style flag

          let profileEvent = {
            kind: 0,
            content: JSON.stringify(cleanMetadata),
            tags: []
          };

          profileEvent = await signEvent(profileEvent, privkey);

          log('Publishing clean profile...', 'info');
          const profPubs = pool.publish(relays, profileEvent);
          await Promise.allSettled(profPubs);
          log('‚úÖ Clean profile published!', 'success');
        }

        log('üéâ Resurrection complete!', 'success');

        // Play resurrection animation
        await playResurrectionAnimation();

        // Remove from list
        deletedProfiles.splice(index, 1);
        displayResults(privkey);

      } catch (error) {
        log(`Resurrection failed: ${error.message}`, 'error');
        btn.disabled = false;
        btn.textContent = '‚ö° Resurrect This Profile';
      }
    }

    async function publishToMissingRelays() {
      const publishBtn = document.getElementById('publish-missing-btn');
      publishBtn.disabled = true;
      publishBtn.textContent = 'üì° Publishing...';

      try {
        const privkey = await getPrivateKey();
        const pubkey = await getPublicKey(privkey);
        const relays = getRelays();

        if (relays.length === 0) {
          throw new Error('Please add at least one relay');
        }

        log('üì° Publishing profile to missing relays...', 'warning');

        // Step 1: Find which relays are missing the profile
        const missingRelays = [];
        for (const relay of relays) {
          try {
            const events = await pool.querySync([relay], {
              kinds: [0],
              authors: [pubkey]
            });

            if (events.length === 0) {
              missingRelays.push(relay);
              log(`${relay.replace('wss://', '')} - MISSING profile`, 'warning');
            } else {
              log(`${relay.replace('wss://', '')} - Has profile`, 'info');
            }
          } catch (err) {
            log(`${relay.replace('wss://', '')}: Error - ${err.message}`, 'error');
          }
        }

        if (missingRelays.length === 0) {
          log('‚úÖ All relays have your profile!', 'success');
          alert('All relays already have your profile. Try Force Resurrection if clients still show deleted.');
          return;
        }

        log(`Found ${missingRelays.length} relay(s) missing your profile`, 'warning');
        log('', 'info');

        // Step 2: Get the latest profile from relays that have it
        log('Fetching your latest profile...', 'info');
        const allEvents = await pool.querySync(relays, {
          kinds: [0],
          authors: [pubkey]
        });

        if (allEvents.length === 0) {
          throw new Error('No profile found on any relay. Use "Update Profile Metadata" to create one.');
        }

        // Find the newest profile
        const latestProfile = allEvents.reduce((latest, event) => {
          return (!latest || event.created_at > latest.created_at) ? event : latest;
        }, null);

        const metadata = JSON.parse(latestProfile.content);
        log(`Latest profile: ${metadata.name || 'unknown'}`, 'info');
        log(`Created: ${new Date(latestProfile.created_at * 1000).toLocaleString()}`, 'info');

        // Add display_name if name exists but display_name doesn't
        if (metadata.name && !metadata.display_name) {
          metadata.display_name = metadata.name;
        }

        // Ensure proper deletion flags for Yakihonne compatibility
        delete metadata.deleted; // Remove old-style deleted flag
        metadata.is_deleted = false; // Add Yakihonne-style flag
        metadata.pubkey = pubkey; // Add pubkey to metadata (Yakihonne includes this)

        // Log what fields we're publishing
        log(`Profile fields: ${Object.keys(metadata).join(', ')}`, 'info');

        // Step 3: Create a NEW profile event with current timestamp
        const newTimestamp = Math.floor(Date.now() / 1000);
        let profileEvent = {
          kind: 0,
          content: JSON.stringify(metadata),
          tags: [],
          created_at: newTimestamp
        };

        profileEvent = await signEvent(profileEvent, privkey);

        log('', 'info');
        log(`Publishing to ${missingRelays.length} missing relay(s)...`, 'info');

        // Step 4: Publish ONLY to missing relays
        for (const relay of missingRelays) {
          try {
            log(`Publishing to ${relay.replace('wss://', '')}...`, 'info');
            const pubs = pool.publish([relay], profileEvent);
            await Promise.allSettled(pubs);
            log(`  ‚úÖ Published to ${relay.replace('wss://', '')}`, 'success');
          } catch (err) {
            log(`  ‚ùå Failed: ${err.message}`, 'error');
          }
        }

        log('', 'info');
        log('üéâ Profile published to missing relays!', 'success');

        // Verify each relay actually has it now
        log('', 'info');
        log('üîç Verifying relays received the profile...', 'info');
        await new Promise(resolve => setTimeout(resolve, 3000)); // Wait 3 seconds

        for (const relay of missingRelays) {
          try {
            const verifyEvents = await pool.querySync([relay], {
              kinds: [0],
              authors: [pubkey]
            });

            if (verifyEvents.length > 0) {
              log(`  ‚úÖ ${relay.replace('wss://', '')} - CONFIRMED (has ${verifyEvents.length} event(s))`, 'success');
            } else {
              log(`  ‚ùå ${relay.replace('wss://', '')} - REJECTED (relay accepted publish but didn't store event)`, 'error');
            }
          } catch (err) {
            log(`  ‚ùå ${relay.replace('wss://', '')} - Error verifying: ${err.message}`, 'error');
          }
        }

        // Play animation
        await playResurrectionAnimation();

        alert(`Profile published to ${missingRelays.length} missing relay(s)! Check the logs to see which relays confirmed storage.`);

      } catch (error) {
        log(`Publish failed: ${error.message}`, 'error');
        alert(`Publish failed: ${error.message}`);
      } finally {
        publishBtn.disabled = false;
        publishBtn.textContent = 'üì° Publish to Missing Relays';
      }
    }

    async function exportProfileData() {
      const exportBtn = document.getElementById('export-btn');
      exportBtn.disabled = true;

      try {
        const privkey = await getPrivateKey();
        const pubkey = await getPublicKey(privkey);
        const relays = getRelays();

        if (relays.length === 0) {
          throw new Error('Please add at least one relay');
        }

        log('üì• Fetching all profile data...', 'info');

        // Fetch all profile events
        const events = await pool.querySync(relays, {
          kinds: [0],
          authors: [pubkey]
        });

        if (events.length === 0) {
          alert('No profile events found on any relay.');
          return;
        }

        // Get the latest profile
        const latestProfile = events.reduce((latest, event) => {
          return (!latest || event.created_at > latest.created_at) ? event : latest;
        }, null);

        const metadata = JSON.parse(latestProfile.content);

        // Create export data
        const exportData = {
          pubkey: pubkey,
          npub: window.NostrTools.nip19.npubEncode(pubkey),
          latestProfileEvent: {
            id: latestProfile.id,
            created_at: latestProfile.created_at,
            created_at_readable: new Date(latestProfile.created_at * 1000).toISOString(),
            kind: latestProfile.kind,
            content: metadata,
            tags: latestProfile.tags
          },
          allProfileEvents: events.map(e => ({
            id: e.id,
            created_at: e.created_at,
            created_at_readable: new Date(e.created_at * 1000).toISOString(),
            content: JSON.parse(e.content)
          })),
          relayStatus: {}
        };

        // Check which relays have the profile
        for (const relay of relays) {
          const eventsOnRelay = await pool.querySync([relay], {
            kinds: [0],
            authors: [pubkey]
          });
          exportData.relayStatus[relay] = eventsOnRelay.length > 0 ? `‚úÖ Has profile (${eventsOnRelay.length} events)` : '‚ùå No profile';
        }

        // Create downloadable JSON file
        const jsonStr = JSON.stringify(exportData, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `nostr-profile-${pubkey.substring(0, 8)}-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        log('‚úÖ Profile data exported!', 'success');
        log(`Latest profile has ${Object.keys(metadata).length} fields: ${Object.keys(metadata).join(', ')}`, 'info');

        alert(`Profile data exported!\n\nFields in profile: ${Object.keys(metadata).join(', ')}`);

      } catch (error) {
        log(`Export failed: ${error.message}`, 'error');
        alert(`Export failed: ${error.message}`);
      } finally {
        exportBtn.disabled = false;
      }
    }

    async function deepScan() {
      const deepScanBtn = document.getElementById('deep-scan-btn');
      deepScanBtn.disabled = true;
      deepScanBtn.textContent = 'üî¨ Deep Scanning...';

      try {
        const privkey = await getPrivateKey();
        const pubkey = await getPublicKey(privkey);
        const relays = getRelays();

        if (relays.length === 0) {
          throw new Error('Please add at least one relay');
        }

        log('üî¨ Starting DEEP SCAN...', 'warning');
        log(`Pubkey: ${pubkey.substring(0, 16)}...`, 'info');
        log('', 'info');

        // Check 1: Kind 0 profile events (metadata)
        log('=== CHECKING KIND 0 (Profile Metadata) ===', 'info');
        for (const relay of relays) {
          try {
            const events = await pool.querySync([relay], {
              kinds: [0],
              authors: [pubkey]
            });

            log(`${relay.replace('wss://', '')}:`, 'info');
            if (events.length === 0) {
              log(`  No profile events found`, 'warning');
            }

            for (const event of events) {
              const metadata = JSON.parse(event.content);
              const isDeleted = metadata.deleted === true;
              const yakihonneDeleted = metadata.is_deleted === true;
              const hasYakihonneFlag = metadata.hasOwnProperty('is_deleted');

              log(`  Event ${event.id.substring(0, 8)}... (${new Date(event.created_at * 1000).toLocaleString()})`, isDeleted || yakihonneDeleted ? 'warning' : 'info');
              log(`    deleted: ${metadata.deleted !== undefined ? metadata.deleted : '(not set)'}`, isDeleted ? 'warning' : 'info');
              log(`    is_deleted: ${metadata.is_deleted !== undefined ? metadata.is_deleted : '(not set)'}`, yakihonneDeleted ? 'warning' : hasYakihonneFlag ? 'success' : 'warning');
              log(`    name: ${metadata.name || '(none)'}`, 'info');
              log(`    pubkey in metadata: ${metadata.pubkey ? 'yes' : 'NO (Yakihonne needs this!)'}`, metadata.pubkey ? 'info' : 'warning');

              if (isDeleted || yakihonneDeleted) {
                log(`    ‚ö†Ô∏è THIS PROFILE IS MARKED AS DELETED!`, 'error');
              }
              if (!hasYakihonneFlag) {
                log(`    ‚ö†Ô∏è MISSING is_deleted flag (Yakihonne may reject this!)`, 'warning');
              }
            }
          } catch (err) {
            log(`${relay.replace('wss://', '')}: Error - ${err.message}`, 'error');
          }
        }

        log('', 'info');

        // Check 2: Kind 5 deletion events
        log('=== CHECKING KIND 5 (Deletion Events) ===', 'info');
        for (const relay of relays) {
          try {
            const deletionEvents = await pool.querySync([relay], {
              kinds: [5],
              authors: [pubkey]
            });

            log(`${relay.replace('wss://', '')}:`, 'info');
            if (deletionEvents.length === 0) {
              log(`  No deletion events found`, 'info');
            } else {
              for (const event of deletionEvents) {
                log(`  Deletion event ${event.id.substring(0, 8)}... (${new Date(event.created_at * 1000).toLocaleString()})`, 'warning');
                log(`    Targets ${event.tags.length} event(s)`, 'warning');
                event.tags.forEach(tag => {
                  if (tag[0] === 'e') {
                    log(`      Deletes event: ${tag[1].substring(0, 16)}...`, 'warning');
                  } else if (tag[0] === 'a') {
                    log(`      Deletes kind: ${tag[1]}`, 'warning');
                  }
                });
                if (event.content) {
                  log(`    Reason: ${event.content}`, 'info');
                }
              }
            }
          } catch (err) {
            log(`${relay.replace('wss://', '')}: Error - ${err.message}`, 'error');
          }
        }

        log('', 'info');

        // Check 3: Kind 3 contact lists (to see if account has any activity)
        log('=== CHECKING KIND 3 (Contact List / Following) ===', 'info');
        try {
          const contactEvents = await pool.querySync(relays, {
            kinds: [3],
            authors: [pubkey],
            limit: 1
          });

          if (contactEvents.length > 0) {
            const event = contactEvents[0];
            log(`Found contact list with ${event.tags.filter(t => t[0] === 'p').length} following`, 'info');
          } else {
            log(`No contact list found (account may be new/unused)`, 'warning');
          }
        } catch (err) {
          log(`Error checking contacts: ${err.message}`, 'error');
        }

        log('', 'info');

        // Check 4: Kind 1 notes (to see if account has posted)
        log('=== CHECKING KIND 1 (Posts/Notes) ===', 'info');
        try {
          const notes = await pool.querySync(relays, {
            kinds: [1],
            authors: [pubkey],
            limit: 5
          });

          if (notes.length > 0) {
            log(`Found ${notes.length} recent post(s)`, 'info');
          } else {
            log(`No posts found (account may be new/unused)`, 'warning');
          }
        } catch (err) {
          log(`Error checking posts: ${err.message}`, 'error');
        }

        log('', 'info');
        log('=== DEEP SCAN COMPLETE ===', 'success');
        log('Review the results above to identify the issue.', 'info');

      } catch (error) {
        log(`Deep scan failed: ${error.message}`, 'error');
      } finally {
        deepScanBtn.disabled = false;
        deepScanBtn.textContent = 'üî¨ Deep Scan (Check Everything)';
      }
    }

    async function updateProfile() {
      const authMethod = document.querySelector('input[name="authMethod"]:checked').value;

      if (authMethod === 'npub') {
        alert('Updating profile requires authentication. Please choose "Browser Extension" or "Private Key" authentication method above.');
        return;
      }

      const updateBtn = document.getElementById('update-profile-btn');
      updateBtn.disabled = true;
      updateBtn.textContent = '‚úèÔ∏è Updating...';

      try {
        const privkey = await getPrivateKey();
        const pubkey = await getPublicKey(privkey);
        const relays = getRelays();

        if (relays.length === 0) {
          throw new Error('Please add at least one relay');
        }

        // Get form values
        const name = document.getElementById('profile-name').value.trim();
        const about = document.getElementById('profile-about').value.trim();
        const picture = document.getElementById('profile-picture').value.trim();
        const banner = document.getElementById('profile-banner').value.trim();

        if (!name && !about) {
          throw new Error('Please enter at least a name or bio');
        }

        log('Updating profile metadata...', 'info');

        // Fetch current profile to preserve other fields
        const events = await pool.querySync(relays, {
          kinds: [0],
          authors: [pubkey],
          limit: 1
        });

        let currentMetadata = {};
        if (events.length > 0) {
          try {
            currentMetadata = JSON.parse(events[0].content);
            log('Found existing profile, will merge metadata', 'info');
          } catch (e) {
            log('Could not parse existing profile, starting fresh', 'warning');
          }
        }

        // Build new metadata - preserve ALL existing fields
        const metadata = { ...currentMetadata };
        if (name) metadata.name = name;
        if (about) metadata.about = about;
        if (picture) metadata.picture = picture;
        if (banner) metadata.banner = banner;

        // Add display_name if name is set but display_name doesn't exist
        if (name && !metadata.display_name) {
          metadata.display_name = name;
        }

        // Ensure proper deletion flags for Yakihonne compatibility
        delete metadata.deleted; // Remove old-style deleted flag
        metadata.is_deleted = false; // Add Yakihonne-style flag
        metadata.pubkey = pubkey; // Add pubkey to metadata (Yakihonne includes this)

        // Log what fields we have
        log(`Profile fields: ${Object.keys(metadata).join(', ')}`, 'info');

        log(`Setting name: ${metadata.name || '(not set)'}`, 'info');
        log(`Setting about: ${metadata.about ? metadata.about.substring(0, 50) + '...' : '(not set)'}`, 'info');

        // Create and sign profile event
        let profileEvent = {
          kind: 0,
          content: JSON.stringify(metadata),
          tags: [],
          created_at: Math.floor(Date.now() / 1000)
        };

        profileEvent = await signEvent(profileEvent, privkey);

        log('Publishing profile to relays...', 'info');
        const pubs = pool.publish(relays, profileEvent);
        await Promise.allSettled(pubs);

        log('‚úÖ Profile updated successfully!', 'success');
        log(`Event ID: ${profileEvent.id}`, 'success');

        alert('Profile updated! Check Primal/Yakihonne in a few moments to see if it appears.');

      } catch (error) {
        log(`Profile update failed: ${error.message}`, 'error');
        alert(`Profile update failed: ${error.message}`);
      } finally {
        updateBtn.disabled = false;
        updateBtn.textContent = '‚úèÔ∏è Update Profile Metadata';
      }
    }

    async function forceResurrection() {
      const authMethod = document.querySelector('input[name="authMethod"]:checked').value;
      const forceBtn = document.getElementById('force-btn');

      // In npub mode, just do a scan
      if (authMethod === 'npub') {
        forceBtn.disabled = true;
        forceBtn.textContent = 'üîç Checking...';

        try {
          await scanProfile();
        } finally {
          forceBtn.disabled = false;
          forceBtn.textContent = 'üîç Check Profile';
        }
        return;
      }

      if (!confirm('This will:\n\n1. Find ALL deleted profile events across all relays\n2. Delete ALL of them with a kind 5 event\n3. Publish a fresh clean profile with a guaranteed newer timestamp\n\nThis is useful when clients still show your profile as deleted.\n\nContinue?')) {
        return;
      }

      forceBtn.disabled = true;
      forceBtn.textContent = '‚ö° Resurrecting...';

      try {
        const privkey = await getPrivateKey();
        const pubkey = await getPublicKey(privkey);
        const relays = getRelays();

        if (relays.length === 0) {
          throw new Error('Please add at least one relay');
        }

        log('üî• Starting FORCED resurrection...', 'warning');
        log(`Pubkey: ${pubkey.substring(0, 8)}...`, 'info');
        log(`Using ${relays.length} relay(s)`, 'info');

        // Step 1: Fetch ALL profile events FROM EACH RELAY individually
        log('Fetching all profile events across relays...', 'info');

        // Query each relay individually to see what each has
        const allEvents = new Map(); // eventId -> event
        const relayEventMap = new Map(); // relay -> [events]

        for (const relay of relays) {
          try {
            log(`Querying ${relay}...`, 'info');
            const eventsFromRelay = await pool.querySync([relay], {
              kinds: [0],
              authors: [pubkey]
            });

            relayEventMap.set(relay, eventsFromRelay);

            for (const event of eventsFromRelay) {
              allEvents.set(event.id, event);
            }

            log(`  - ${relay}: ${eventsFromRelay.length} event(s)`, 'info');
          } catch (err) {
            log(`  - ${relay}: Error - ${err.message}`, 'error');
          }
        }

        const events = Array.from(allEvents.values());
        log(`Found ${events.length} unique profile event(s) total across all relays`, 'info');

        // Find all deleted profiles and get latest metadata
        const deletedEventIds = [];
        let latestCleanMetadata = null;
        let latestDeletedMetadata = null;
        let newestTimestamp = 0;

        for (const event of events) {
          try {
            const metadata = JSON.parse(event.content);

            // Show which relays have this specific event
            const relaysWithThisEvent = [];
            for (const [relay, eventsFromRelay] of relayEventMap.entries()) {
              if (eventsFromRelay.some(e => e.id === event.id)) {
                relaysWithThisEvent.push(relay);
              }
            }

            if (metadata.deleted === true) {
              deletedEventIds.push(event.id);
              log(`Found DELETED profile: ${event.id.substring(0, 8)}... (timestamp: ${event.created_at})`, 'warning');
              log(`  On relays: ${relaysWithThisEvent.map(r => r.replace('wss://', '')).join(', ')}`, 'warning');
              log(`  Content: ${JSON.stringify(metadata).substring(0, 150)}...`, 'warning');
              latestDeletedMetadata = metadata;
            } else {
              log(`Found clean profile: ${event.id.substring(0, 8)}... (timestamp: ${event.created_at})`, 'info');
              log(`  On relays: ${relaysWithThisEvent.map(r => r.replace('wss://', '')).join(', ')}`, 'info');
              latestCleanMetadata = metadata;
            }

            if (event.created_at > newestTimestamp) {
              newestTimestamp = event.created_at;
            }
          } catch (err) {
            log(`Error parsing event ${event.id.substring(0, 8)}...: ${err.message}`, 'error');
          }
        }

        // Step 2: If we found deleted events, send kind 5 deletion
        if (deletedEventIds.length > 0) {
          log(`Found ${deletedEventIds.length} deleted event(s) to remove`, 'warning');

          let deletionEvent = {
            kind: 5,
            content: 'Force removing all deleted profile events',
            tags: deletedEventIds.map(id => ['e', id])
          };

          deletionEvent = await signEvent(deletionEvent, privkey);

          log('Publishing deletion event...', 'info');
          const delPubs = pool.publish(relays, deletionEvent);
          await Promise.allSettled(delPubs);
          log('‚úÖ Deletion event published!', 'success');

          await new Promise(resolve => setTimeout(resolve, 1000));
        } else {
          log('No deleted events found, but will still publish fresh profile', 'info');
        }

        // Step 3: Publish fresh clean profile
        log('Publishing fresh clean profile...', 'info');

        // Use the latest metadata we have (prefer clean over deleted)
        const baseMetadata = latestCleanMetadata || latestDeletedMetadata || {};
        const cleanMetadata = { ...baseMetadata };

        // If profile is completely empty, add minimal required fields
        if (Object.keys(cleanMetadata).length === 0) {
          log('‚ö†Ô∏è Profile is empty! Adding minimal required fields...', 'warning');
          cleanMetadata.name = 'Nostr User';
          cleanMetadata.about = 'Nostr user';
        }

        // Add display_name if name exists but display_name doesn't
        if (cleanMetadata.name && !cleanMetadata.display_name) {
          cleanMetadata.display_name = cleanMetadata.name;
        }

        // Ensure proper deletion flags for Yakihonne compatibility
        delete cleanMetadata.deleted; // Remove old-style deleted flag
        cleanMetadata.is_deleted = false; // Add Yakihonne-style flag
        cleanMetadata.pubkey = pubkey; // Add pubkey to metadata (Yakihonne includes this)

        // Log what fields we're publishing
        log(`üìù Profile fields being published: ${Object.keys(cleanMetadata).join(', ')}`, 'success');
        log(`üìù Profile content preview: ${JSON.stringify(cleanMetadata).substring(0, 200)}...`, 'info');

        // Make timestamp newer than everything
        const currentTimestamp = Math.floor(Date.now() / 1000);
        const newTimestamp = Math.max(currentTimestamp, newestTimestamp + 1);

        log(`New profile timestamp: ${newTimestamp} (newest existing: ${newestTimestamp})`, 'info');

        let profileEvent = {
          kind: 0,
          content: JSON.stringify(cleanMetadata),
          tags: [],
          created_at: newTimestamp
        };

        profileEvent = await signEvent(profileEvent, privkey);

        log('Publishing clean profile...', 'info');

        // Log the EXACT event being published
        log('üì§ Publishing this exact event:', 'info');
        log(`   Event ID: ${profileEvent.id}`, 'info');
        log(`   Content: ${profileEvent.content.substring(0, 300)}...`, 'info');

        // Publish to each relay individually so we can track success/failure
        let successCount = 0;
        let failCount = 0;

        for (const relay of relays) {
          try {
            log(`Publishing to ${relay.replace('wss://', '')}...`, 'info');
            const pubs = pool.publish([relay], profileEvent);
            const results = await Promise.allSettled(pubs);

            // Check if at least one publish succeeded
            const succeeded = results.some(r => r.status === 'fulfilled');

            if (succeeded) {
              successCount++;
              log(`  ‚úÖ ${relay.replace('wss://', '')} - SUCCESS`, 'success');
            } else {
              failCount++;
              log(`  ‚ùå ${relay.replace('wss://', '')} - FAILED`, 'error');
            }
          } catch (err) {
            failCount++;
            log(`  ‚ùå ${relay.replace('wss://', '')} - ERROR: ${err.message}`, 'error');
          }
        }

        log(`‚úÖ Published to ${successCount}/${relays.length} relay(s)`, successCount > 0 ? 'success' : 'error');
        if (failCount > 0) {
          log(`‚ö†Ô∏è Failed on ${failCount} relay(s)`, 'warning');
        }

        log('üéâ Force resurrection complete!', 'success');

        // Play resurrection animation
        await playResurrectionAnimation();

        // Verify
        await new Promise(resolve => setTimeout(resolve, 2000));
        log('Verifying...', 'info');
        const verifyEvents = await pool.querySync(relays, {
          kinds: [0],
          authors: [pubkey]
        });
        log(`Now seeing ${verifyEvents.length} total profile event(s)`, 'info');

        alert('Force resurrection complete! Check your profile on different clients (Primal, Yakihonne, etc.) to verify.');

      } catch (error) {
        log(`Force resurrection failed: ${error.message}`, 'error');
        alert(`Force resurrection failed: ${error.message}`);
      } finally {
        forceBtn.disabled = false;
        forceBtn.textContent = '‚ö° Force Resurrection';
      }
    }
  </script>
</body>
</html>
